{"version":3,"file":"BestTeamWorker-DXLlCd86.js","sources":["../src/types/EnemyTypes.ts","../src/models/BattleConditionParser.ts","../src/utils/helpers.ts","../src/types/KiokuTypes.ts","../src/models/ScoreAttackTeam.ts","../src/models/Kioku.ts","../src/models/ScoreAttackKioku.ts","../src/models/BestTeamCalculator.ts","../src/workers/BestTeamWorker.js"],"sourcesContent":["export enum EnemyTargetTypes {\n    L_OTHER,\n    L_PROXIMITY,\n    TARGET,\n    R_PROXIMITY,\n    R_OTHER,\n}\n\nexport interface Enemy {\n    name: string\n    maxBreak: number\n    defense: number\n    defenseUp: number\n    hitsToKill: number\n    enabled: boolean\n    isBreak: boolean\n    isWeak: boolean\n    isCrit: boolean\n}","import battleConditionSetsJson from '../assets/base_data/getBattleConditionSetMstList.json';\nimport battleConditionsJson from '../assets/base_data/getBattleConditionMstList.json';\nimport { BattleState, PassiveSkill, SkillDetail } from '../types/KiokuTypes';\nimport { KiokuState } from './PvPTeam';\n\ninterface BattleCondition {\n    battleConditionMstId: number\n    compareContent: number\n    compareOperator: number\n    compareTarget: number\n    compareValue: string\n    description: string\n}\n\nconst battleConditions = Object.fromEntries(\n    battleConditionsJson.map((item: any) => [item.battleConditionMstId, item])\n) as Record<string, BattleCondition>;\n\ninterface BattleConditionSet {\n    battleConditionMstIdCsv: string\n    battleConditionSetMstId: number\n    description: string\n}\n\nconst battleConditionSets = Object.fromEntries(\n    battleConditionSetsJson.map((item: any) => [item.battleConditionSetMstId, item])\n) as Record<string, BattleConditionSet>;\n\n\nexport enum ProcessTiming {\n    NONE = 0,\n    BATTLE_START = 1,\n    WAVE_START = 2,\n    TURN_START = 3,\n    ATTACK_START = 4,\n    ATTACK_END = 5,\n    TURN_END = 6,\n    WAVE_END = 7,\n    BATTLE_END = 8,\n    AFTER_PROCESS = 9,\n}\n\nexport const isTimingActive = (startTiming: ProcessTiming, eff: PassiveSkill) => {\n    if (!eff.startTimingIdCsv || eff.startTimingIdCsv === \"0\") {\n        console.error(\"Unknown start timing\", eff)\n        return false\n    }\n    for (const startTimingId of eff.startTimingIdCsv.split(\",\")) {\n        if (startTiming === Number(startTimingId)) return true\n    }\n    return false\n}\n\nenum CompareContent {\n    NONE = 0,\n    HP = 1,\n    HP_RATIO = 2,\n    ATK = 3,\n    DEF = 4,\n    SPD = 5,\n    EP = 6,\n    TURN = 7,\n    IS_ACTOR = 8,\n    IS_MAIN_TARGET = 9,\n    IS_FRIEND = 10,\n    IS_OPPONENT = 11,\n    ABILITY_EFFECT = 12,\n    EVERY_N_TURN = 13,\n    CHARACTER = 14,\n    HP_GAUGE_COUNT = 15,\n    IS_BREAK = 16,\n    CHARGE_POINT = 17,\n    CAN_NOT_ACTION = 18,\n    IS_ELEMENT_TYPE = 19,\n    IS_ROLE_TYPE = 20,\n    BREAKED_DAMAGE_RECEIVE_RATE = 21,\n    IS_MAX_BREAKED_DAMAGE_RECEIVE_RATE = 22,\n    ABNORMAL_STATE_COUNT = 23,\n    BUFF_COUNT = 24,\n    DEBUFF_COUNT = 25,\n    HAS_BUFF = 26,\n    X_KYOUKO_DEBUFF_COUNT = 27,\n    SELF_IS_KIOKU = 28,\n    DMG = 101,\n    DMG_RATIO = 102,\n    IS_KILLED = 103,\n    IS_RECOVERY = 104,\n    IS_BARRIER_ADDED = 105,\n    IS_BARRIER_ATTACKED = 106,\n    IS_BARRIER_DESTROYED = 107,\n    BREAKED_DAMAGE_RECEIVE_RATE_BECOME_MAX = 108,\n    IS_WEAK_ELEMENT_ATTACKED = 109,\n    IS_DURING_ATTACK = 110,\n    WHEN_DOT_IS_PROCCED = 111,\n    HAS_ALIMENT = 112,\n    SP = 201,\n    ALIVE_UNIT_COUNT = 202,\n    DEAD_UNIT_COUNT = 203,\n    APPLIED_SKILL_EFFECT_TYPE = 204,\n    ABILITY_EFFECT_UNIT_COUNT = 205,\n    BREAKED_DAMAGE_RECEIVE_RATE_GREATER_THAN_UNIT_COUNT = 206,\n    BREAKED_DAMAGE_RECEIVE_RATE_LESS_THAN_UNIT_COUNT = 207,\n    NR_OF_DEBUFFS = 208,\n    SIGILS_APPLIED_COUNT = 209,\n    OTHER_BUFF_COUNT = 210,\n    KILLED_UNIT_COUNT = 301,\n    BREAKED_UNIT_COUNT = 302,\n    CTD_UNIT_COUNT = 303,\n    TOTAL_DAMAGE = 304,\n    ABILITY_EFFECT_AND_DAMAGE = 305,\n    BREAKED_UNIT_TOTAL_COUNT = 306,\n    WEAK_ELEMENT_ATTACKED_UNIT_COUNT = 307,\n    BREAKED_DAMAGE_RECEIVE_RATE_BECOME_MAX_UNIT_COUNT = 308,\n    HAS_BUFxF_APPLIED = 309,\n    ONGOING_DAMAGE = 310,\n    ACTOR_SKILL_TYPE = 401,\n    COMBO_ACTION_STEP = 402,\n}\n\nenum CompareOperator {\n    NONE = 0,\n    EQUAL = 1,\n    NOT_EQUAL = 2,\n    GREATER = 3,\n    GREATER_OR_EQUAL = 4,\n    LESS = 5,\n    LESS_OR_EQUAL = 6,\n    CONTAIN = 7,\n    NOT_CONTAIN = 8,\n}\n\nenum CompareTarget {\n    NONE = 0,\n    SELF = 1,\n    ACTOR = 2,\n    MAIN_TARGET = 3,\n    EACH_TARGET = 8,\n    ALL_TARGETS = 4,\n    FRIEND_TEAM = 5,\n    OPPONENT_TEAM = 6,\n    OTHERS = 7,\n}\n\nObject.values(battleConditions).forEach(c => {\n    if (!(c.compareContent in CompareContent)) {\n        console.error(\"Unknown CompareContent\", c)\n    }\n    if (!(c.compareOperator in CompareOperator)) {\n        console.error(\"Unknown compareOperator\", c)\n    }\n    if (!(c.compareTarget in CompareTarget)) {\n        console.error(\"Unknown compareTarget\", c)\n    }\n})\n\nconst isCondActive = (cond: BattleCondition, valueToCompareTo: any): boolean => {\n    if (typeof valueToCompareTo === \"boolean\") valueToCompareTo = valueToCompareTo ? \"TRUE\" : \"FALSE\"\n    if (cond.compareOperator === CompareOperator.EQUAL) {\n        return valueToCompareTo == cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.NOT_EQUAL) {\n        return valueToCompareTo != cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.GREATER) {\n        return valueToCompareTo > cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.GREATER_OR_EQUAL) {\n        return valueToCompareTo >= cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.LESS) {\n        return valueToCompareTo < cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.LESS_OR_EQUAL) {\n        return valueToCompareTo <= cond.compareValue\n    }\n    if (cond.compareOperator === CompareOperator.CONTAIN) {\n        return valueToCompareTo.includes(cond.compareValue)\n    }\n    if (cond.compareOperator === CompareOperator.NOT_CONTAIN) {\n        return !valueToCompareTo.includes(cond.compareValue)\n    }\n    return true;\n}\n\nconst lateGetIsActiveCond = (cond: BattleCondition) =>\n    (amountOfEnemies: number, maxBreak: number) =>\n        cond.compareContent === CompareContent.ALIVE_UNIT_COUNT\n            ? isCondActive(cond, amountOfEnemies)\n            : isCondActive(cond, maxBreak)\n\nexport const getDescriptionOfCond = (battleConditionSetId: string): string => battleConditionSets[battleConditionSetId].description\n\nexport const isStartCondRelevantForScoreAttack = (startConditionId: string, maxMagicStacks: number): boolean => {\n    if (!startConditionId || startConditionId === \"0\") return true\n\n    const battleConditionSet = battleConditionSets[startConditionId]\n    for (const activeCondId of battleConditionSet.battleConditionMstIdCsv.split(\",\")) {\n        const battleCondition = battleConditions[activeCondId]\n\n        if (battleCondition.compareContent === CompareContent.CHARGE_POINT) {\n            if (!isCondActive(battleCondition, maxMagicStacks)) return false\n        }\n    }\n    return true;\n}\n\nexport const isActiveConditionRelevantForScoreAttack = (activeConditionSetId: string, attackerHealth: number, activeAliments: string[]): boolean | Function => {\n    if (!activeConditionSetId || activeConditionSetId === \"0\") return true\n\n    const battleConditionSet = battleConditionSets[activeConditionSetId]\n\n    for (const activeCondId of battleConditionSet.battleConditionMstIdCsv.split(\",\")) {\n        const battleCondition = battleConditions[activeCondId]\n        if (battleCondition.compareContent === CompareContent.ACTOR_SKILL_TYPE &&\n            [\"NormalAttack\", \"ActiveSkill\"].includes(battleCondition.compareValue)) return false\n\n        if (battleCondition.compareValue === \"AdditionalSkill\" &&\n            battleCondition.compareOperator === CompareOperator.EQUAL) {\n            return false\n        }\n        if (battleCondition.compareContent === CompareContent.ALIVE_UNIT_COUNT) {\n            // NOTE: This is incorrect as it breaks the loop, but unlikely that it actually matters ever\n            return lateGetIsActiveCond(battleCondition)\n        }\n        if (battleCondition.compareContent === CompareContent.ABILITY_EFFECT) {\n            if (!isCondActive(battleCondition, activeAliments)) return false\n        }\n        if (battleCondition.compareContent === CompareContent.BREAKED_DAMAGE_RECEIVE_RATE) {\n            return lateGetIsActiveCond(battleCondition)\n        }\n        if (battleCondition.compareContent === CompareContent.HP_RATIO) {\n            if (!isCondActive(battleCondition, attackerHealth)) return false\n        }\n\n        if (battleCondition.compareContent === CompareContent.X_KYOUKO_DEBUFF_COUNT) {\n            if (!isCondActive(battleCondition, \"5,10\")) return false\n        }\n    }\n    return true\n}\n\n\nconst targetsToCompareTo = (compareTarget: CompareTarget, state: BattleState): KiokuState[] => {\n    if (compareTarget === CompareTarget.SELF) return [state.actor]\n    if (compareTarget === CompareTarget.ACTOR) return [state.actor]\n    if (compareTarget === CompareTarget.MAIN_TARGET) return [state.target]\n    if (compareTarget === CompareTarget.ALL_TARGETS) return [state.target]\n    if (compareTarget === CompareTarget.FRIEND_TEAM) return state.actorTeam.kiokuStates\n    if (compareTarget === CompareTarget.OPPONENT_TEAM) return state.enemyTeam.kiokuStates\n    return [state.actor]\n}\n\nexport const conditionSetRequiresActorIsSelf = (eff: SkillDetail) =>\n    eff.startConditionSetIdCsv.length && eff.startConditionSetIdCsv.split(\",\").some(conditionSetId => {\n        const battleConditionSet = battleConditionSets[conditionSetId]\n        return battleConditionSet.battleConditionMstIdCsv.split(\",\").some(condId => condId === \"3\")\n    })\n\nexport const isConditionSetActive = (eff: SkillDetail, state: BattleState) =>\n    isConditionSetActiveForPvP(eff.activeConditionSetIdCsv.split(\",\"), state)\n    && isConditionSetActiveForPvP(eff.startConditionSetIdCsv.split(\",\"), state)\n\nexport const isConditionSetActiveForPvP = (conditionSetIdCsvList: string[], {\n    actorTeam,\n    enemyTeam,\n    actor,\n    target,\n    actionType\n}: BattleState): boolean =>\n    conditionSetIdCsvList.every(conditionSetIdCsv => conditionSetIdCsv.split(\",\").every(conditionSetId => {\n        if (!conditionSetId.length || conditionSetId === \"0\") return true\n\n        const battleConditionSet = battleConditionSets[conditionSetId]\n        for (const conditionId of battleConditionSet.battleConditionMstIdCsv.split(\",\")) {\n            const battleCondition = battleConditions[conditionId]\n\n            const compTargets = targetsToCompareTo(battleCondition.compareTarget, {\n                actorTeam,\n                enemyTeam,\n                actor,\n                target,\n                actionType\n            })\n\n            if (battleCondition.compareContent === CompareContent.HP_RATIO) {\n                if (!isCondActive(battleCondition, actor.currentHpPercent)) return false\n            } else if (battleCondition.compareContent === CompareContent.IS_ACTOR) {\n                if (!isCondActive(battleCondition, target.teamLabel !== actor.teamLabel ? true : actor === target)) return false\n            } else if (battleCondition.compareContent === CompareContent.ALIVE_UNIT_COUNT) {\n                if (!isCondActive(battleCondition, enemyTeam.kiokuStates.length)) return false\n            } else if (battleCondition.compareContent === CompareContent.BREAKED_UNIT_COUNT) {\n                if (!isCondActive(battleCondition, enemyTeam.kiokuStates.filter(k => k.currentRemainingBreakGauge <= 0 && !k.isBroken).length)) return false\n            } else if (battleCondition.compareContent === CompareContent.CHARGE_POINT) {\n                if (!isCondActive(battleCondition, actor.currentMagic)) return false\n            } else if (battleCondition.compareContent === CompareContent.IS_FRIEND) {\n                if (!isCondActive(battleCondition, target.teamLabel === actor.teamLabel)) return false\n            } else if (battleCondition.compareContent === CompareContent.ACTOR_SKILL_TYPE) {\n                if (!actionType || !isCondActive(battleCondition, actionType)) return false\n            } else if (battleCondition.compareContent === CompareContent.ABILITY_EFFECT) {\n                if (!Object.values(target.activeEffectDetails).some(e => isCondActive(battleCondition, e.abilityEffectType))) return false\n            } else if (battleCondition.compareContent === CompareContent.BUFF_COUNT) {\n                console.log(\"Found buffs\", compTargets.reduce((acc, k) => acc + k.numberOfBuffs(), 0))\n                if (!isCondActive(battleCondition, compTargets.reduce((acc, k) => acc + k.numberOfBuffs(), 0))) return false\n            } else if (battleCondition.compareContent === CompareContent.DEBUFF_COUNT) {\n                if (!isCondActive(battleCondition, compTargets.reduce((acc, k) => acc + k.numberOfDebuffs(), 0))) return false\n            } else if (battleCondition.compareContent === CompareContent.NR_OF_DEBUFFS) {\n                if (!isCondActive(battleCondition, compTargets.reduce((acc, k) => acc + k.numberOfDebuffs(), 0))) return false\n            } else if (battleCondition.compareContent === CompareContent.BREAKED_DAMAGE_RECEIVE_RATE_BECOME_MAX_UNIT_COUNT) {// TODO\n                if (!isCondActive(battleCondition, 0)) return false // TODO fix\n            } else if (battleCondition.compareContent === CompareContent.TOTAL_DAMAGE) {\n                if (!isCondActive(battleCondition, 1000)) return false // TODO fix\n            } else {\n                console.warn(`Unknown condition ${battleCondition.compareContent}`, battleCondition)\n            }\n        }\n        return true\n    }))\n","import selectionAbilityJson from '../assets/base_data/getSelectionAbilityMstList.json';\nimport portraitsJson from '../assets/base_data/getCardMstList.json';\nimport portraitLevelsJson from '../assets/base_data/getCardLimitBreakMstList.json';\nimport passiveDetailsJson from '../assets/base_data/getPassiveSkillDetailMstList.json';\nimport skillDetailsJson from '../assets/base_data/getSkillDetailMstList.json';\nimport styleParamUpJson from '../assets/base_data/getStyleParamUpMstList.json';\nimport styleParamUpEffectJson from '../assets/base_data/getStyleParamUpEffectMstList.json';\nimport characterHeartParamUpGroupJson from '../assets/base_data/getCharacterHeartParamUpGroupMstList.json';\nimport characterHeartJson from '../assets/base_data/getCharacterHeartMstList.json';\nimport kiokuDataJson from '../assets/base_data/kioku_data.json';\nimport { Portrait, CrystalisData, KiokuData, PortraitLvlData, StyleParamUpEffect, CharacterHeart, CharacterHeartParamUpGroup, ActiveSkill, PassiveSkill, StyleParamUp } from '../types/KiokuTypes';\n\nconst portraitLevels = Object.fromEntries(\n    portraitLevelsJson.map((item: any) => [item.cardLimitBreakMstId, item])\n) as Record<string, PortraitLvlData>;\n\nexport const portraits = Object.fromEntries(\n    portraitsJson.filter(item => item.rarity === 5).map((item: any) => [item.name, { ...item, stats: portraitLevels[item.cardMstId * 10 + 5] }])\n) as Record<string, Portrait>;\n\nexport const passiveDetails = Object.fromEntries(\n    passiveDetailsJson.map((item: any) => [item.passiveSkillDetailMstId, item])\n) as Record<string, PassiveSkill>;\n\nexport const skillDetails = Object.fromEntries(\n    skillDetailsJson.map((item: any) => [item.skillDetailMstId, item])\n) as Record<string, ActiveSkill>;\n\nexport const crystalises = Object.fromEntries(\n    selectionAbilityJson.map((item: any) => [item.name, item])\n) as Record<string, CrystalisData>;\n\nexport const styleParamUpEffect = Object.fromEntries(\n    styleParamUpEffectJson.map((item: any) => [item.styleParamUpEffectMstId, item])\n) as Record<string, StyleParamUpEffect>;\n\nexport const styleParamUp = Object.fromEntries(\n    styleParamUpJson.map((item: any) => [item.styleParamUpMstId, item])\n) as Record<string, StyleParamUp>;\n\nexport const characterHeartParamUpGroup = Object.fromEntries(\n    characterHeartParamUpGroupJson.map((item: any) => [item.characterHeartParamUpGroupMstId, item])\n) as Record<string, CharacterHeartParamUpGroup>;\n\nexport const characterHeart = Object.fromEntries(\n    characterHeartJson.map((item: any) => [item.characterMstId, item])\n) as Record<string, CharacterHeart>;\n\nexport const kiokuData = kiokuDataJson as unknown as Record<string, KiokuData>;\n","import { PvPTeam, KiokuState } from \"../models/PvPTeam\";\nimport { crystalises, kiokuData, portraits } from \"../utils/helpers\";\n\n\nexport enum BasicIds {\n    CRYS = 11,\n    SUPPORT = 22,\n    ASCENSION = 33,\n    PORTRAIT = 44,\n}\n\nexport enum KiokuElement {\n    Flame = \"Flame\",\n    Aqua = \"Aqua\",\n    Forest = \"Forest\",\n    Light = \"Light\",\n    Dark = \"Dark\",\n    Void = \"Void\"\n}\n\nexport enum Aliment {\n    BURN = \"BURN\",\n    CURSE = \"CURSE\",\n    POISON = \"POISON\",\n    STUN = \"STUN\",\n    VORTEX = \"VORTEX\",\n    WEAKNESS = \"WEAKNESS\",\n    WOUND = \"BLEED\",\n}\n\nexport const elementAlimentMap: Record<KiokuElement, Aliment> = {\n    [KiokuElement.Flame]: Aliment.BURN,\n    [KiokuElement.Aqua]: Aliment.WEAKNESS,\n    [KiokuElement.Forest]: Aliment.POISON,\n    [KiokuElement.Light]: Aliment.STUN,\n    [KiokuElement.Dark]: Aliment.CURSE,\n    [KiokuElement.Void]: Aliment.WOUND,\n};\n\nexport enum KiokuRole {\n    Attacker = \"Attacker\",\n    Buffer = \"Buffer\",\n    Debuffer = \"Debuffer\",\n    Healer = \"Healer\",\n    Breaker = \"Breaker\",\n    Defender = \"Defender\"\n}\n\nexport type SupportKey = KiokuRole | KiokuElement\n\nexport const elementMap: Record<string, KiokuElement> = {\n    1: KiokuElement.Flame,\n    2: KiokuElement.Aqua,\n    3: KiokuElement.Forest,\n    4: KiokuElement.Light,\n    5: KiokuElement.Dark,\n    6: KiokuElement.Void,\n};\n\nconst portraitPriority = (elem?: KiokuElement): string[] => [\n    \"A Dream of a Little Mermaid\",\n    \"The Savior's Apostle\",\n    \"Faith We'll Meet Again Someday\",\n    \"Farewell to a Future Unseen\",\n    \"For Hope That Lies Ahead\",\n    \"Proof of Friends Again\",\n    ...(elem ? [dmgUpPortraits[elem]] : []),\n    \"\",\n];\n\nconst getPortraitPriority = (name: string, elem?: KiokuElement) => {\n    const order = portraitPriority(elem);\n    const idx = order.indexOf(name);\n    return idx === -1 ? order.length : idx;\n};\n\nexport const getPortraits = (elem?: KiokuElement): string[] => {\n    return [\n        { name: \"\" },\n        ...Object.values(portraits),\n    ]\n        .sort((a, b) => {\n            const pa = getPortraitPriority(a.name, elem);\n            const pb = getPortraitPriority(b.name, elem);\n\n            if (pa !== pb) return pa - pb;\n\n            return a.name.localeCompare(b.name, undefined, {\n                numeric: true,\n                sensitivity: \"base\",\n            });\n        })\n        .map(p => p.name);\n};\n\nexport const portraitsBestOnly = (elem: KiokuElement) => [\n    \"A Dream of a Little Mermaid\", \"The Savior's Apostle\", \"Faith We'll Meet Again Someday\"\n]\n\nconst dmgUpPortraits = {\n    [KiokuElement.Flame]: \"A Reluctant Coach Steps Up\",\n    [KiokuElement.Aqua]: \"Futures Felt in Photographs\",\n    [KiokuElement.Forest]: \"Special Stage Persona\",\n    [KiokuElement.Light]: \"High Five for Harmony\",\n    [KiokuElement.Dark]: \"One Time Team-up!\",\n    [KiokuElement.Void]: \"Pride on the Line\",\n}\n\nexport interface Portrait {\n    cardMstId: number;\n    passiveSkill1: number;\n    element: number;\n    rarity: number;\n    name: string;\n    resourceName: string;\n    stats: PortraitLvlData\n}\n\nexport interface PortraitLvlData {\n    atk: number;\n    def: number;\n    hp: number;\n}\n\nexport interface MagicLevel {\n    eff: string\n    val: number\n}\n\nexport interface PassiveSkill {\n    abilityEffectType: string\n    activeConditionSetIdCsv: string\n    description: string\n    descriptionType: number\n    element: number\n    passiveSkillDetailMstId: number\n    passiveSkillMstId: number\n    range: number\n    remainCount: number\n    role: number\n    startConditionSetIdCsv: string\n    startTimingIdCsv: string\n    turn: number\n    value1: number\n    value2: number\n    value3: number\n}\n\nexport interface ActiveSkill {\n    abilityEffectType: string\n    activeConditionSetIdCsv: string\n    description: string\n    descriptionType: number\n    element: number\n    probability: number\n    range: number\n    remainCount: number\n    role: number\n    skillDetailMstId: number\n    skillMstId: number\n    startConditionSetIdCsv: string\n    turn: number\n    value1: number\n    value2: number\n    value3: number\n    value4: number\n}\n\nexport type SkillDetail = PassiveSkill | ActiveSkill;\nexport const skillDetailId = (d: SkillDetail) => \"skillDetailMstId\" in d ? d.skillDetailMstId : d.passiveSkillDetailMstId\nexport type SkillKey = \"skillMstId\" | \"passiveSkillMstId\";\n\nexport interface Character {\n    ascension: number\n    character_en: string\n    crys_sub: string[]\n    crys: string[]\n    element: KiokuElement\n    enabled: boolean\n    heartphial: string\n    heartphialLvl: number\n    id: number\n    kiokuLvl: number\n    magicLvl: number\n    name: string\n    obtain: string\n    permaDate: string\n    portrait: string\n    rarity: number\n    role: KiokuRole\n    specialLvl: number\n    supportDescription: string\n    supportTarget: SupportKey\n    dupes: number\n}\n\nexport interface TeamSnapshotList {\n    sp: number\n    team: TeamSnapshot[]\n}\n\nexport interface TeamSnapshot {\n    spd: number\n    atk: number\n    baseSpd: number\n    magicStacks: number\n    maxMagicStacks: number\n    secondsLeft: number\n    distanceLeft: number\n    id: number\n    breakCurrent: number\n    maxBreakGauge: number\n    mp: number\n    maxMp: number\n    name: string\n}\n\nexport interface BattleSnapshot {\n    allies: TeamSnapshotList\n    enemies: TeamSnapshotList\n    lastActor?: string\n    lastTeamIsTeam1?: boolean\n    lastTargetType?: TargetType\n}\n\nexport interface KiokuData {\n    ability_id: number\n    atk100: number\n    atka5: number\n    attack_id: number\n    character_en: string\n    crystalis_effect: string\n    crystalis_id: number\n    def100: number\n    defa5: number\n    element: KiokuElement\n    ep: number\n    heartphial: string\n    hp100: number\n    hpa5: number\n    id: number\n    maxMagicStacks?: number\n    minAtk: number\n    minCritDmg: number\n    minCritRate: number\n    minDef: number\n    minHp: number\n    minSpd: number\n    name: number\n    obtain: string\n    permaDate: string\n    rarity: number\n    role: KiokuRole\n    skill_id: number\n    special_id: number\n    support_effect: string\n    support_id: number\n    support_target: SupportKey\n    ascension_1_effect_2_id: number\n    ascension_2_effect_2_id: number\n    ascension_3_effect_2_id?: number\n    ascension_4_effect_2_id: number\n    ascension_5_effect_2_id?: number\n}\n\nexport interface CrystalisData {\n    name: string\n    description: string\n    rarity: number\n    value1: number\n    styleMstId: number\n    selectionAbilityType: number\n}\n\nexport interface StyleParamUp {\n    styleParamUpMstId: number\n    styleMstId: number\n    styleParamUpTreeMstId: number\n    priority: number\n    styleParamUpEffectMstId: number\n}\n\nexport interface StyleParamUpEffect {\n    abilityEffectType: string\n    name: string\n    styleParamUpEffectMstId: number\n    targetType: number\n    value1: number\n    value2: number\n}\n\nexport interface CharacterHeart {\n    characterHeartMstId: number\n    characterMstId: number\n    objectRewardGroupId: number\n    paramUpGroupId: number\n}\n\nexport interface CharacterHeartParamUpGroup {\n    characterHeartParamUpGroupMstId: number\n    heartLevel: number\n    paramUpGroupId: number\n    styleParamUpEffectMstId: number\n}\n\nexport const getPersonalCrystalisEffects = (styleId: number): string[] =>\n    Object.values(kiokuData).find(k => k.id === styleId)?.crystalis_effect?.split(\"<br>\") ?? []\n\n\nconst crystalisePriority = (elem?: KiokuElement): string[] => [\n    \"EX\",\n    \"Dominant Blow++\",\n    \"Mighty Hit++\",\n    \"Towering Offense++\",\n    \"Quickstep++\",\n    ...(elem ? [elementalCrystalises[elem]] : []),\n    \"\",\n];\n\nconst getCrysSortOrder = (name: string, elem?: KiokuElement) => {\n    const order = crystalisePriority(elem);\n    const idx = order.indexOf(name);\n    return idx === -1 ? order.length : idx;\n};\n\nexport const getCrystalises = (elem?: KiokuElement) => {\n    return [\n        { name: \"EX\", styleMstId: 0, selectionAbilityType: 1 },\n        { name: \"\", styleMstId: 0, selectionAbilityType: 1 },\n        ...Object.values(crystalises),\n    ]\n        .filter(c => c.styleMstId === 0 && c.selectionAbilityType === 1)\n        .sort((a, b) => {\n            const pa = getCrysSortOrder(a.name, elem);\n            const pb = getCrysSortOrder(b.name, elem);\n\n            if (pa !== pb) return pa - pb;\n\n            return a.name.localeCompare(b.name, undefined, {\n                numeric: true,\n                sensitivity: \"base\",\n            });\n        })\n        .map(c => c.name);\n};\n\nexport const getBestCrystalises = (elem: KiokuElement) => [\n    \"EX\",\n    \"Dominant Blow++\",\n    \"Mighty Hit++\",\n    \"Towering Offense++\",\n    elementalCrystalises[elem]\n\n]\nconst elementalCrystalises = {\n    [KiokuElement.Flame]: \"Inferno++\",\n    [KiokuElement.Aqua]: \"Torrent++\",\n    [KiokuElement.Forest]: \"Verdure++\",\n    [KiokuElement.Light]: \"Radiance++\",\n    [KiokuElement.Dark]: \"Chaos++\",\n    [KiokuElement.Void]: \"Nullity++\",\n}\n\nconst priorityOrder = [\n    \"Increases ATK by 60.\",\n    \"Increases critical DMG by 10%.\",\n    \"Increases critical rate by 5%.\",\n    \"Increases SPD by 4.\",\n    \"\",\n];\n\nconst subCrysTranslate = (name: string): string => {\n    const transformed = name\n        .replace(\"Increases \", \"\")\n        .replace(\" by \", \" +\")\n        .replace(/\\.$/, \"\")\n        .replace(\" %\", \"%\");\n\n    return transformed.charAt(0).toUpperCase() + transformed.slice(1);\n};\n\nconst getSubCrysSortOrder = (name: string) => {\n    const idx = priorityOrder.indexOf(name);\n    return idx === -1 ? priorityOrder.length : idx;\n};\n\nexport const getSubCrystalises = () => {\n    return [\n        { name: \"\", selectionAbilityType: 2, description: \"\" },\n        ...Object.values(crystalises),\n    ]\n        .filter(c => c.selectionAbilityType === 2)\n        .sort((a, b) => {\n            const pa = getSubCrysSortOrder(a.description);\n            const pb = getSubCrysSortOrder(b.description);\n\n            if (pa !== pb) return pa - pb;\n\n            return a.description.localeCompare(b.description, undefined, {\n                numeric: true,\n                sensitivity: \"base\",\n            });\n        })\n        .map(c => ({ name: c.name, description: subCrysTranslate(c.description) }))\n};\n\nexport const KiokuConstants = {\n    maxKiokuLvl: 120,\n    maxMagicLvl: 130,\n    maxAscension: 5,\n    maxHeartphialLvl: 50,\n    maxSpecialLvl: 10,\n    optimal_attacker_crys_sub: Array(3).fill([\"Increases critical rate by 5%.\", \"Increases critical DMG by 10%.\", \"Increases ATK by 60.\"]).flat()\n}\n\n\n\nexport interface KiokuArgs {\n    name: string;\n    kiokuLvl: number;\n    magicLvl: number;\n    heartphialLvl: number;\n    portrait?: string;\n    supportKey?: any[];\n    crys: string[];\n    crys_sub: string[]\n    ascension: number;\n    specialLvl: number;\n}\n\nexport const correctCharacterParams = (character?: Character) => {\n    if (character) {\n        if (character.ascension < 3) {\n            character.specialLvl = Math.min(character.specialLvl, 4)\n        } else if (character.ascension < 5) {\n            character.specialLvl = Math.min(character.specialLvl, 7)\n        }\n    }\n    return character\n}\n\nexport const maxMeters = 10_000\n\nexport const aggro = {\n    [KiokuRole.Defender]: 15,\n    [KiokuRole.Buffer]: 10,\n    [KiokuRole.Debuffer]: 10,\n    [KiokuRole.Healer]: 10,\n    [KiokuRole.Attacker]: 5,\n    [KiokuRole.Breaker]: 5,\n}\n\nexport enum TargetType {\n    specialId = \"SpecialAttack\",\n    skillId = \"ActiveSkill\",\n    attackId = \"NormalAttack\",\n    fuaId = \"AdditionalSkill\",\n}\n\nexport const TargetTypeLookup = {\n    [TargetType.specialId]: \"special_id\",\n    [TargetType.skillId]: \"skill_id\",\n    [TargetType.attackId]: \"attack_id\",\n}\n\nexport const targetTypeToLvl = {\n    [TargetType.specialId]: \"specialLvl\",\n    [TargetType.skillId]: \"skillLvl\",\n    [TargetType.attackId]: \"attackLvl\",\n}\n\nexport enum targetRange {\n    SELF = -1,\n    TARGET = 1,\n    PROXIMITY = 2,\n    ALL = 3,\n}\n\nexport const defaultbreak = {\n    [TargetType.specialId]: { [targetRange.TARGET]: 35, [targetRange.PROXIMITY]: 30, [targetRange.ALL]: 25 },\n    [TargetType.skillId]: { [targetRange.TARGET]: 20, [targetRange.PROXIMITY]: 15, [targetRange.ALL]: 12 },\n    [TargetType.attackId]: { [targetRange.TARGET]: 10 },\n    [TargetType.fuaId]: { [targetRange.TARGET]: 0 }, // TODO: Check\n}\n\nexport const mpGainFromAction = {\n    [TargetType.specialId]: 5,\n    [TargetType.skillId]: 30,\n    [TargetType.attackId]: 15,\n    [TargetType.fuaId]: 0,\n}\n\nexport interface BattleState {\n    actorTeam: PvPTeam,\n    enemyTeam: PvPTeam,\n    actor: KiokuState,\n    target: KiokuState,\n    actionType?: TargetType\n}","import { ScoreAttackKioku } from \"./ScoreAttackKioku\";\nimport { EnemyTargetTypes, Enemy } from \"../types/EnemyTypes\";\nimport { isActiveConditionRelevantForScoreAttack, isStartCondRelevantForScoreAttack } from \"./BattleConditionParser\";\nimport { ActiveSkill, Aliment, elementMap, SkillDetail, skillDetailId } from \"../types/KiokuTypes\";\n\nconst targetTypeAtPosition = [EnemyTargetTypes.L_OTHER, EnemyTargetTypes.L_PROXIMITY, EnemyTargetTypes.TARGET, EnemyTargetTypes.R_PROXIMITY, EnemyTargetTypes.R_OTHER]\n\nconst knownBoosts = {\n    DWN_DEF_ACCUM_RATIO: \"Def%2\",\n    DWN_DEF_RATIO: \"Def%1\",\n    DWN_ELEMENT_RESIST_ACCUM_RATIO: \"Elem Resist-\",\n    FLAT_ATK: \"Flat atk\",\n    UP_AIM_RCV_DMG_RATIO: \"Elem DMG Taken+\",\n    UP_ATK_ACCUM_RATIO: \"Atk%2\",\n    UP_ATK_FIXED: \"FlatAtk\",\n    UP_ATK_RATIO: \"Atk%1\",\n    UP_CTD_ACCUM_RATIO: \"CD2+\",\n    UP_CTD_FIXED: \"CD1+\",\n    UP_CTD_RATIO: \"CD3+\",\n    UP_CTR_ACCUM_RATIO: \"CR2+\",\n    UP_CTR_FIXED: \"CR1+\",\n    UP_CTR_RATIO: \"CR3+\",\n    UP_DEF_ACCUM_RATIO: \"Def%1\",\n    UP_DEF_FIXED: \"Flat def\",\n    UP_DEF_RATIO: \"Def%2\",\n    UP_DMG_DEALT: \"Additional dmg\", // TODO: Check that this is correct. How does it scale w buff+, how to put into dmg calc?\n    UP_ELEMENT_DMG_RATE_RATIO: \"Dmg Dealt+ (Elem only)\",\n    UP_GIV_DMG_RATIO: \"DMG Dealt+\",\n    UP_RCV_CTR_RATIO: \"CR4+\",\n    UP_RCV_DMG_RATIO: \"DMG Taken+\",\n    UP_WEAK_ELEMENT_DMG_RATIO: \"Elem Dmg+\",\n    WEAKNESS: \"Def%3\",\n};\n\nconst skippable = new Set([\n    \"ADD_BUFF_TURN\",\n    \"ADD_DEBUFF_TURN\",\n    \"ADDITIONAL_SKILL_ACT\",\n    \"ADDITIONAL_TURN_UNIT_ACT\",\n    \"BARRIER\",\n    \"BLEED_ATK\",\n    \"BURN_ATK\",\n    \"CHARGE\",\n    \"CONSUME_CHARGE_POINT\",\n    \"CONSUME_COUNT_POINT\",\n    \"CONTINUOUS_RECOVERY\",\n    \"COUNT\",\n    \"CURSE_ATK\",\n    \"CUTOUT\",\n    \"DMG_ATK\",\n    \"DMG_DEF\",\n    \"DMG_RANDOM\",\n    \"DOWN_SPD_RATIO\",\n    \"DWN_ATK_RATIO\",\n    \"DWN_RCV_DMG_RATIO\",\n    \"DWN_SPD_ACCUM_RATIO\",\n    \"DWN_SPD_RATIO\",\n    \"GAIN_CHARGE_POINT\",\n    \"GAIN_COUNT_POINT\",\n    \"GAIN_EP_FIXED\",\n    \"GAIN_EP_RATIO\",\n    \"GAIN_SP_FIXED\",\n    \"HASTE\",\n    \"IMM_SLIP_DMG\",\n    \"POISON_ATK\",\n    \"RE_ACTION_TURN_UNIT_ACT\",\n    \"RECOVERY_HP_ATK\",\n    \"RECOVERY_HP\",\n    \"REFLECTION_RATIO\",\n    \"REMOVE_ALL_ABNORMAL\",\n    \"REMOVE_ALL_BUFF\",\n    \"REMOVE_ALL_DEBUFF\",\n    \"SHIELD\",\n    \"SLOW\",\n    \"STUN\",\n    \"SWITCH_SKILL\",\n    \"TSUBAME_CORE\",\n    \"TSUBAME_LINK\",\n    \"UNIQUE_10030301\",\n    \"UNIQUE_10070201\",\n    \"UNIQUE_BUFF\",\n    \"UNIQUE_DEBUFF_ACCUM\",\n    \"UNIQUE_DEBUFF\",\n    \"UP_ABNORMAL_HIT_RATE_RATIO\",\n    \"UP_BREAK_DAMAGE_RECEIVE_RATIO\",\n    \"UP_BREAK_EFFECT\",\n    \"UP_BUFF_EFFECT_VALUE\",\n    \"UP_BUFF_EFFECT_VALUE\",\n    \"UP_DEBUFF_EFFECT_VALUE\",\n    \"UP_EFFECT_HIT_RATE_RATIO\",\n    \"UP_EFFECT_PARRY_RATE_RATIO\",\n    \"UP_EP_RECOVER_RATE_RATIO\",\n    \"UP_GIV_BREAK_POINT_DMG_FIXED\",\n    \"UP_GIV_SLIP_DMG_RATIO\",\n    \"UP_GIV_VORTEX_DMG_RATIO\",\n    \"UP_HATE\",\n    \"UP_HEAL_RATE_RATIO\",\n    \"UP_HP_FIXED\",\n    \"UP_HP_RATIO\",\n    \"UP_RCV_BREAK_POINT_DMG_RATIO\",\n    \"UP_SPD_ACCUM_RATIO\",\n    \"UP_SPD_FIXED\",\n    \"UP_SPD_RATIO\",\n    \"VORTEX_ATK\", // TODO: Make vortex work\n]);\n\nconst bannedEffects: Set<number> = new Set([\n    65101002, // Sakurako passive is listed multiple places\n    65101003, // Sakurako passive is listed multiple places\n]);\n\nfunction prettyNumber(n: number) {\n    const rounded = Math.round((n + Number.EPSILON) * 100) / 100;\n    return Number(rounded.toString());\n}\n\nexport class ScoreAttackTeam {\n    private team: ScoreAttackKioku[];\n    private dps: ScoreAttackKioku;\n    private all_effects: Record<string, number> = {};\n    private extra_effects: Record<string, [Function, number][]> = {};\n    private debug: boolean;\n    private attackerHealth: number;\n    private activeBuffsAndDebuffs: string[];\n    private debugTexts: Record<string, Record<string, [SkillDetail, number][]>> = {}\n\n    constructor(dps: ScoreAttackKioku, team: ScoreAttackKioku[], attackerHealth: number, activeAliments: Aliment[], debug = false) {\n        this.team = team;\n        this.dps = dps;\n        this.debug = debug;\n        this.attackerHealth = attackerHealth;\n        this.activeBuffsAndDebuffs = activeAliments;\n        this.all_effects[\"DWN_DEF_ACCUM_RATIO\"] = 1\n        this.all_effects[\"DWN_DEF_RATIO\"] = 1\n        this.all_effects[\"WEAKNESS\"] = 0\n        this.setup();\n    }\n\n    private setup() {\n        const members: [boolean, ScoreAttackKioku][] = [\n            [true, this.dps],\n            ...this.team.map(t => [false, t] as [boolean, ScoreAttackKioku])\n        ];\n        for (const [_, kioku] of members) {\n            kioku.effects = kioku.effects.filter(detail => {\n                if (Aliment.WEAKNESS === detail.abilityEffectType && !(this.activeBuffsAndDebuffs.includes(Aliment.WEAKNESS))) {\n                    return false;\n                }\n                if (!this.activeBuffsAndDebuffs.includes(detail.abilityEffectType)) {\n                    this.activeBuffsAndDebuffs.push(detail.abilityEffectType)\n                }\n                return true;\n            })\n        }\n        for (const [isDps, kioku] of members) {\n            this.debugTexts[kioku.name] = {}\n            for (const detail of kioku.effects) {\n                if (skippable.has(detail.abilityEffectType)) continue\n                if (bannedEffects.has(skillDetailId(detail))) continue\n                if (!isDps && detail.range < 1) continue\n                if (detail.element && elementMap[detail.element] !== this.dps.data.element) continue\n\n                if (detail.startConditionSetIdCsv.split(\",\").some(startCondId =>\n                    !isStartCondRelevantForScoreAttack(startCondId, kioku.maxMagicStacks))\n                ) continue;\n\n                let valueTotal = detail.value1\n                // For multi-value skills, value2 is the max multiplier \n                valueTotal *= detail.value2 || 1\n\n                detail.activeConditionSetIdCsv.split(\",\").forEach(activeCondId => {\n                    const isActiveCond = isActiveConditionRelevantForScoreAttack(activeCondId, this.attackerHealth, this.activeBuffsAndDebuffs)\n                    if (typeof (isActiveCond) === 'boolean') {\n                        if (isActiveCond) {\n                            if (detail.abilityEffectType in this.all_effects) {\n                                if ([\"DWN_DEF_RATIO\", \"DWN_DEF_ACCUM_RATIO\"].includes(detail.abilityEffectType)) {\n                                    this.all_effects[detail.abilityEffectType] *= 1 - valueTotal / 1000;\n                                } else if (detail.abilityEffectType === \"WEAKNESS\") {\n                                    this.all_effects[detail.abilityEffectType] += 1;\n                                } else {\n                                    this.all_effects[detail.abilityEffectType] += valueTotal\n                                }\n                            } else {\n                                this.all_effects[detail.abilityEffectType] = valueTotal;\n                            }\n                            if (!(detail.abilityEffectType in this.debugTexts[kioku.name])) {\n                                this.debugTexts[kioku.name][detail.abilityEffectType] = []\n                            }\n                            this.debugTexts[kioku.name][detail.abilityEffectType].push([detail, valueTotal])\n                        }\n                    } else {\n                        if (!(detail.abilityEffectType in this.extra_effects)) {\n                            this.extra_effects[detail.abilityEffectType] = []\n                        }\n                        this.extra_effects[detail.abilityEffectType].push([isActiveCond, valueTotal])\n                    }\n                })\n            }\n        }\n\n        if (this.debug) {\n            console.log(\"Total effects\", Object.fromEntries(Object.entries(this.all_effects).filter(\n                ([key, _]) => (key in knownBoosts)\n            )));\n            console.log(\"Extra effects\", Object.fromEntries(Object.entries(this.extra_effects).filter(\n                ([key, _]) => (key in knownBoosts)\n            )));\n        }\n\n        const leftover = Object.keys(this.all_effects).filter(\n            key => !(key in knownBoosts) && !skippable.has(key)\n        );\n        if (leftover.length > 0) {\n            throw new Error(`Found unknown effects: ${leftover.join(\", \")}`);\n        }\n    }\n\n    memberForLog = (idx: number): ScoreAttackKioku => {\n        if (idx === EnemyTargetTypes.TARGET) return this.dps\n        if (idx < EnemyTargetTypes.TARGET) return this.team[idx]\n        return this.team[idx - 1]\n    }\n\n    calculate_max_dmg(\n        enemies: Enemy[],\n        atk_down = 0,\n    ): [number, number, number, string[]] {\n        let dmg, avg_dmg, enemyDied;\n        let total_dmg = 0;\n        let average_dmg = 0;\n        let critRate = 0;\n        let debugText = \"\"\n        let amountOfEnemies = enemies.filter(e => e.enabled).length\n        const debugTexts = [\"\", \"\", \"\", \"\", \"\"];\n        for (const i of [EnemyTargetTypes.TARGET, EnemyTargetTypes.L_PROXIMITY, EnemyTargetTypes.R_PROXIMITY, EnemyTargetTypes.L_OTHER, EnemyTargetTypes.R_OTHER]) {\n            [dmg, avg_dmg, critRate, debugText, enemyDied] = this.calculate_single_dmg(i, this.memberForLog(i), enemies[i], amountOfEnemies, atk_down)\n            total_dmg += dmg\n            average_dmg += avg_dmg\n            if (enemies[i].enabled && enemyDied) amountOfEnemies -= 1\n            debugTexts[i] = debugText\n        }\n        return [total_dmg, average_dmg, Math.round(critRate * 100), debugTexts]\n    }\n\n    getEffect(eff: string, amountOfEnemies: number, maxBreak: number): number {\n        let val = this.all_effects[eff] ?? 0\n        this.extra_effects[eff]?.forEach(\n            ([fun, v]) => {\n                if (fun(amountOfEnemies, maxBreak)) {\n                    if ([\"DWN_DEF_RATIO\", \"DWN_DEF_ACCUM_RATIO\"].includes(eff)) {\n                        val *= 1 - v / 1000;\n                    } else {\n                        val += v\n                    }\n                }\n            })\n        return val\n    }\n\n    get_special_dmg(targetType: EnemyTargetTypes, amountOfEnemies: number, maxBreak: number, nrHitThatKills: number): [number, boolean, boolean] {\n        let total_dmg = 0;\n        let uses_def = false;\n        for (const detail of this.dps.effects) {\n            if (((detail as ActiveSkill).skillMstId / 100 | 0) !== this.dps.data.special_id) continue\n            let delta_dmg = 0\n            if (!detail.abilityEffectType.startsWith(\"DMG_\")) continue\n            if (detail.abilityEffectType.includes(\"DEF\")) uses_def = true\n            detail.activeConditionSetIdCsv.split(\",\").forEach(activeCondId => {\n                const isActiveCond = isActiveConditionRelevantForScoreAttack(activeCondId, this.attackerHealth, this.activeBuffsAndDebuffs)\n                if (typeof (isActiveCond) === 'boolean') {\n                    if (!isActiveCond) return\n                } else {\n                    if (!isActiveCond(nrHitThatKills > 1 ? amountOfEnemies : amountOfEnemies - 1, maxBreak)) return;\n                }\n\n                if (detail.abilityEffectType === \"DMG_RANDOM\" && targetType === EnemyTargetTypes.TARGET) delta_dmg = detail.value1 * detail.value2;\n                // We make random only hit lowest def for simplicity, since this is max dmg\n                else if (detail.range === 3) delta_dmg = detail.value1; // 3 is all enemies\n                else if (detail.range === 2 && (targetType === EnemyTargetTypes.L_PROXIMITY || targetType === EnemyTargetTypes.R_PROXIMITY)) delta_dmg = detail.value2;\n                else if (targetType === EnemyTargetTypes.TARGET) delta_dmg = detail.value1;\n\n                if (!(detail.abilityEffectType in this.debugTexts[this.dps.name])) {\n                    this.debugTexts[this.dps.name][detail.abilityEffectType] = []\n                }\n                this.debugTexts[this.dps.name][detail.abilityEffectType].push([detail, delta_dmg])\n                nrHitThatKills--;\n            })\n            total_dmg += delta_dmg\n        }\n        return [total_dmg / 1000, nrHitThatKills < 1, uses_def]\n    }\n\n    calculate_single_dmg(\n        idx: number,\n        kiokuAtPosition: ScoreAttackKioku,\n        enemy: Enemy,\n        amountOfEnemies: number,\n        atk_down: number,\n    ): [number, number, number, string, boolean] {\n        // TODO: Add atk%-, dmg taken down% and dmg dealt down% from enemies\n        const [special, enemyDied, uses_def] = this.get_special_dmg(targetTypeAtPosition[idx], amountOfEnemies, enemy.maxBreak, enemy.hitsToKill);\n        const base_atk = uses_def ? this.dps.getBaseDef() : this.dps.getBaseAtk();\n        const atk_pluss =\n            (this.getEffect(`UP_${uses_def ? \"DEF\" : \"ATK\"}_RATIO`, amountOfEnemies, enemy.maxBreak) +\n                (this.getEffect(`UP_${uses_def ? \"DEF\" : \"ATK\"}_ACCUM_RATIO`, amountOfEnemies, enemy.maxBreak))) /\n            1000;\n        const flat_atk = this.getEffect(`UP_${uses_def ? \"DEF\" : \"ATK\"}_FIXED`, amountOfEnemies, enemy.maxBreak)\n        const atk_total = base_atk * (1 + atk_pluss) * (1 - atk_down) + flat_atk\n\n        let def_remaining = (\n            this.getEffect(\"DWN_DEF_ACCUM_RATIO\", amountOfEnemies, enemy.maxBreak) *\n            this.getEffect(\"DWN_DEF_RATIO\", amountOfEnemies, enemy.maxBreak) *\n            (0.9 ** this.all_effects[\"WEAKNESS\"]) // Weakness acts as -10% def\n        );\n\n        const def_total = enemy.defense * (1 + enemy.defenseUp / 100) * def_remaining;\n\n        const uncapped_crit_rate = (this.dps.baseCritRate +\n            this.getEffect(\"UP_CTR_ACCUM_RATIO\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_CTR_FIXED\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_RCV_CTR_RATIO\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_CTR_RATIO\", amountOfEnemies, enemy.maxBreak)) /\n            1000\n\n        const crit_rate = Math.min(1, uncapped_crit_rate)\n\n        const crit_dmg = (this.dps.baseCritDamage +\n            this.getEffect(\"UP_CTD_FIXED\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_CTD_RATIO\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_CTD_ACCUM_RATIO\", amountOfEnemies, enemy.maxBreak)\n        ) / 1000;\n        const dmg_pluss = (\n            this.getEffect(\"UP_GIV_DMG_RATIO\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_ELEMENT_DMG_RATE_RATIO\", amountOfEnemies, enemy.maxBreak)\n        ) / 1000;\n        const elem_dmg_up = (this.getEffect(\"UP_WEAK_ELEMENT_DMG_RATIO\", amountOfEnemies, enemy.maxBreak)) / 1000;\n        const dmg_taken = (this.getEffect(\"UP_RCV_DMG_RATIO\", amountOfEnemies, enemy.maxBreak) +\n            this.getEffect(\"UP_AIM_RCV_DMG_RATIO\", amountOfEnemies, enemy.maxBreak)) / 1000;\n        const elem_res_down = (this.getEffect(\"DWN_ELEMENT_RESIST_ACCUM_RATIO\", amountOfEnemies, enemy.maxBreak)) / 1000;\n        const base_dmg = special * base_atk * ((base_atk / 124) ** 1.2 + 12) / 20;\n\n        const def_factor = Math.min(2, ((atk_total + 10) / (def_total + 10)) * 0.12);\n        const crit_factor = 1 + (enemy.isCrit ? crit_dmg : 0);\n        const crit_average = 1 + (crit_rate * crit_dmg);\n        const dmg_dealt_factor = 1 + dmg_pluss;\n        const dmg_taken_factor = 1 + dmg_taken;\n        const elem_resist_factor = 1 + elem_res_down;\n        const effect_elem_factor = 1 + (enemy.isWeak ? 0.2 + elem_dmg_up : 0);\n        const break_factor = (enemy.isBreak ? enemy.maxBreak / 100 : 1);\n\n        const before_crit_total =\n            Number(enemy.enabled) *\n            base_dmg *\n            def_factor *\n            dmg_dealt_factor *\n            dmg_taken_factor *\n            elem_resist_factor *\n            effect_elem_factor *\n            break_factor;\n        const total = before_crit_total * crit_factor\n        const average_total = before_crit_total * crit_average\n\n        let debugText = \"\";\n        if (this.debug) {\n            const lines = kiokuAtPosition\n                ? Object.keys(kiokuAtPosition).sort().sort((a, b) => {\n                    if (a.endsWith(\"Atk\")) return -1;\n                    if (b.endsWith(\"Atk\")) return 1;\n                    if (a === \"portrait\") return -1;\n                    if (b === \"portrait\") return 1;\n                    if (a === \"support\") return -1;\n                    if (b === \"support\") return 1;\n                    if (a.endsWith(\"Lvl\")) return -1;\n                    if (b.endsWith(\"Lvl\")) return 1;\n                    return 0\n                }).map(key => {\n                    let val = (kiokuAtPosition as any)[key]\n                    if (key.startsWith(\"base\") || key.endsWith(\"Def\") || key.endsWith(\"Hp\")) return;\n                    if ([\"effects\", \"ascension\", \"crys\", \"data\", \"inputCrys\", \"inputCrysSub\", \"name\", \"scalableEffects\", \"unscalableEffects\"].includes(key)) {\n                        return;\n                    }\n                    if (key === \"portrait\") {\n                        val = val?.[\"stats\"]?.[\"atk\"];\n                        key = \"PortraitAtk\";\n                    }\n                    if (key === \"support\") {\n                        val = val?.getBaseAtk() * 0.16;\n                        key = \"SupportAtk\";\n                    }\n                    if (key === \"supportLvl\") {\n                        val = (kiokuAtPosition as any)[\"support\"]?.supportLvl ?? \"N/A\"\n                    }\n                    if (key.endsWith(\"Atk\")) {\n                        val |= 0;\n                    }\n                    val = prettyNumber(val).toString()\n                    if (key === \"SupportAtk\" || key === \"supportLvl\") {\n                        val = val + \"\\n\"\n                    }\n                    return `${key.padEnd(12)} - ${val}`\n                }).filter(Boolean)\n                : [];\n\n            const effects = kiokuAtPosition ? Object.keys(this.debugTexts[kiokuAtPosition.name]).sort().map(key =>\n                `${key} \\n ${this.debugTexts[kiokuAtPosition.name][key].sort((a, b) => a[1] - b[1]).map(([d, n]) => {\n                    let st = \"\"\n                    if (d.activeConditionSetIdCsv.length) {\n                        st += \"A\" + d.activeConditionSetIdCsv\n                    }\n                    if (d.startConditionSetIdCsv.length) {\n                        if (st.length) {\n                            st += \" & \"\n                        }\n                        st += \"S\" + d.startConditionSetIdCsv\n                    }\n                    let outString = `${prettyNumber(n / 10)} (${skillDetailId(d)})`\n                    if (st.length) {\n                        outString += \" => \" + st\n                    }\n                    const desc = d.description.match(/.{1,20}/g)?.join(\"\\n   \")\n                    outString += `${desc ? `\\n  ${desc}` : ''}`\n                    return outString\n                }\n                ).join(\"\\n \")}`\n            ).filter(Boolean) : []\n\n\n            debugText = ` \nDMG CALC MULTIPLIERS:\nDPS stats:\nAbility Mult - ${special * 100 | 0}%\nBase ${uses_def ? \"Def\" : \"Atk\"}  - ${(base_atk | 0).toLocaleString()}\n${uses_def ? \"Def\" : \"Atk\"} Up %     - ${atk_pluss * 100 | 0}%\n${uses_def ? \"Def\" : \"Atk\"} Up flat  - ${flat_atk | 0}\nTotal ${uses_def ? \"Def\" : \"Atk\"}    - ${(atk_total | 0).toLocaleString()}\nDef down%    - ${(1 - def_remaining) * 100 | 0}%\nTotal def    - ${(def_total | 0).toLocaleString()}\nCrit rate    - ${uncapped_crit_rate * 100 | 0}%\nCrit dmg     - ${crit_dmg * 100 | 0}%\nDmg Dealt    - ${dmg_pluss * 100 | 0}%\nElem dmg up  - ${elem_dmg_up * 100 | 0}%\nDmg Taken    - ${dmg_taken * 100 | 0}%\nElem Res     - ${elem_res_down * 100 | 0}%\natk down     - ${atk_down * 100 | 0}%\n\nFORMULA:\nAbility dmg  - ${(base_dmg | 0).toLocaleString()}\nDef Factor   - ${def_factor * 100 | 0}%\nCrit Factor  - ${crit_factor * 100 | 0}%\nDmg Dlt Fact - ${dmg_dealt_factor * 100 | 0}%\nDmg Tkn Fact - ${dmg_taken_factor * 100 | 0}%\nElem ResFact - ${elem_resist_factor * 100 | 0}%\nEffElem Fact - ${effect_elem_factor * 100 | 0}%\nBreak Factor - ${break_factor * 100 | 0}%\nResult       - ${(total | 0).toLocaleString()}\nAverageDmg   - ${(average_total | 0).toLocaleString()}\n\nENEMY STATS:\nenemiesAlive - ${amountOfEnemies}    \nbase_def     - ${enemy.defense.toLocaleString()}    \nbreak        - ${enemy.maxBreak}% \ndef_up       - ${enemy.defenseUp}%  \nis_break     - ${enemy.isBreak}    \nis_elemt_weak- ${enemy.isWeak}         \ndoes_crit    - ${enemy.isCrit}         \nenabled      - ${enemy.enabled}\nenemy died   - ${enemyDied}\n\nKIOKU STATS:\n${lines.join(\"\\n\")}\n\nKIOKU EFFECTS:\n${effects.join(\"\\n\")}`;\n        }\n\n        return [total | 0, average_total | 0, crit_rate, debugText, enemyDied];\n    }\n}\n","import { KiokuArgs, KiokuConstants, KiokuData, Portrait, StyleParamUpEffect } from '../types/KiokuTypes';\nimport { portraits, kiokuData, crystalises, characterHeart, characterHeartParamUpGroup, styleParamUpEffect, styleParamUp } from '../utils/helpers';\nimport { fromKey } from '../models/BestTeamCalculator';\n\nexport class Kioku {\n    name: string;\n    protected support?: Kioku;\n    protected portrait?: Portrait;\n\n    private inputCrys: string[];\n    private inputCrysSub: string[];\n\n    protected ascension: number;\n    private kiokuLvl: number;\n    private magicLvl: number;\n    private heartphialLvl: number;\n\n    supportLvl = 1;\n    protected skillLvl = 1;\n    protected abilityLvl = 1;\n    protected attackLvl = 1;\n    protected specialLvl: number;\n    protected crys: number[] = [];\n\n    data: KiokuData;\n\n    private kiokuAtk: number;\n    private kiokuDef: number;\n    private kiokuHp: number;\n    private magicAtk: number = 0;\n    private magicDef: number = 0;\n    private magicHp: number = 0;\n    private heartAtk: number = 0;\n    private heartDef: number = 0;\n    private heartHp: number = 0;\n\n    baseCritRate: number\n    baseCritDamage: number;\n\n    maxMagicStacks = 0;\n\n    getBaseAtk(): number {\n        return (this.kiokuAtk * (1 + 0.02 * this.ascension) + (this.support?.getBaseAtk() ?? 0) * 0.16 + (this.portrait?.stats?.atk ?? 0) + this.magicAtk + this.heartAtk);\n    }\n\n    getBaseDef(): number {\n        return (this.kiokuDef * (1 + 0.02 * this.ascension) + (this.support?.getBaseDef() ?? 0) * 0.16 + (this.portrait?.stats?.def ?? 0) + this.magicDef + this.heartDef);\n    }\n\n    getBaseHp(): number {\n        return (this.kiokuHp * (1 + 0.02 * this.ascension) + (this.support?.getBaseHp() ?? 0) * 0.16 + (this.portrait?.stats?.hp ?? 0) + this.magicHp + this.heartHp);\n    }\n\n    constructor({\n        name,\n        supportKey,\n        portrait,\n        ascension,\n        kiokuLvl,\n        magicLvl,\n        heartphialLvl,\n        specialLvl,\n        crys,\n        crys_sub\n    }: KiokuArgs) {\n        this.name = name;\n        this.data = kiokuData[name];\n\n        if (portrait) this.portrait = portraits[portrait]\n        if (supportKey) this.support = fromKey(supportKey);\n\n        this.inputCrys = crys?.filter(Boolean) ?? [];\n        this.inputCrysSub = crys_sub?.filter(Boolean) ?? [];\n\n        this.ascension = ascension;\n        this.kiokuLvl = kiokuLvl;\n        this.magicLvl = magicLvl;\n        this.heartphialLvl = heartphialLvl;\n        this.specialLvl = specialLvl;\n        this.maxMagicStacks = this.data.maxMagicStacks ?? 0\n        this.baseCritDamage = this.data.minCritDmg * 10\n        this.baseCritRate = this.data.minCritRate * 10\n\n        this.kiokuAtk = this.data.minAtk + (this.kiokuLvl - 1) * (this.data.atk100 - this.data.minAtk) / (KiokuConstants.maxKiokuLvl - 1);\n        this.kiokuDef = this.data.minDef + (this.kiokuLvl - 1) * (this.data.def100 - this.data.minDef) / (KiokuConstants.maxKiokuLvl - 1);\n        this.kiokuHp = this.data.minHp + (this.kiokuLvl - 1) * (this.data.hp100 - this.data.minHp) / (KiokuConstants.maxKiokuLvl - 1);\n\n        const heartGroup = characterHeart[this.data.id / 10_000]?.paramUpGroupId ?? 1;\n        for (const v of Object.values(characterHeartParamUpGroup)) {\n            if (v.paramUpGroupId === heartGroup && this.heartphialLvl > v.heartLevel) {\n                this.addStat(v.styleParamUpEffectMstId, false);\n            }\n        }\n\n        for (const v of Object.values(styleParamUp)) {\n            if (v.styleMstId === this.data.id && v.priority <= this.magicLvl) {\n                this.addStat(v.styleParamUpEffectMstId, true);\n            }\n        }\n\n        for (const c of [...this.inputCrys, ...this.inputCrysSub]) {\n            if (c === \"EX\") {\n                this.crys.push(this.data.crystalis_id)\n            } else if (c in crystalises) {\n                this.crys.push(crystalises[c].value1)\n            } else {\n                console.error(\"Could not find\", c, \"in crystalises\")\n            }\n        }\n    }\n\n    addStat(styleParamUpEffectMstId: number, isMagic: boolean) {\n        const eff = styleParamUpEffect[styleParamUpEffectMstId] as StyleParamUpEffect\n\n        switch (eff.abilityEffectType || eff.name) {\n            case \"UP_ATK_FIXED\":\n                if (isMagic) this.magicAtk += eff.value1\n                else this.heartAtk += eff.value1\n                break;\n            case \"UP_DEF_FIXED\":\n                if (isMagic) this.magicDef += eff.value1\n                else this.heartDef += eff.value1\n                break;\n            case \"UP_HP_FIXED\":\n                if (isMagic) this.magicHp += eff.value1\n                else this.heartHp += eff.value1\n                break;\n            case \"UP_CTR_FIXED\":\n                this.baseCritRate += eff.value1\n                break;\n            case \"UP_CTD_FIXED\":\n                this.baseCritDamage += eff.value1\n                break;\n            case \"Support Ability Lvl. Up\":\n                this.supportLvl += 1;\n                break;\n            case \"Battle Skill Lvl. Up\":\n                this.skillLvl += 1;\n                break;\n            case \"Ability Lvl. Up\":\n                this.abilityLvl += 1;\n                break;\n            case \"Basic Attack Lvl. Up\":\n                this.attackLvl += 1;\n                break;\n            default:\n                console.warn(\"Missing lvl\", eff)\n        }\n    }\n\n    getKey(): any[] {\n        return [\n            this.name,\n            this.support?.getKey(),\n            this.portrait,\n            this.ascension,\n            this.kiokuLvl,\n            this.magicLvl,\n            this.heartphialLvl,\n            this.specialLvl,\n            this.inputCrys,\n            this.inputCrysSub,\n        ];\n    }\n}\n","import { ActiveSkill, KiokuArgs, KiokuData, SkillDetail, SkillKey } from '../types/KiokuTypes';\nimport { passiveDetails, skillDetails } from '../utils/helpers';\nimport { Kioku } from './Kioku';\n\n\nexport class ScoreAttackKioku extends Kioku {\n    effects: SkillDetail[];\n    private scalableEffects: SkillDetail[] = [];\n    private unscalableEffects: SkillDetail[] = [];\n    private buffMult = 1;\n    private debuffMult = 1;\n\n    constructor(args: KiokuArgs, buffMultReduction = 0, debuffMultReduction = 0) {\n        super(args);\n        this.buffMult -= buffMultReduction / 100;\n        this.debuffMult -= debuffMultReduction / 100;\n\n        if (this.support && [this.data.role, this.data.element].includes(this.support.data.support_target)) {\n            this.addEffect(passiveDetails, \"passiveSkillMstId\", this.support.data.support_id, this.support.supportLvl, false);\n        }\n        if (this.portrait) {\n            this.addEffect(passiveDetails, \"passiveSkillMstId\", this.portrait.passiveSkill1, 6, false);\n        }\n        for (let i = 1; i <= this.ascension; i++) {\n            const passiveId = this.data[`ascension_${i}_effect_2_id` as keyof KiokuData] as number;\n            if (passiveId) this.addEffect(passiveDetails, \"passiveSkillMstId\", passiveId, 1, true);\n\n        }\n        this.crys.forEach(c => {\n            this.addEffect(passiveDetails, \"passiveSkillMstId\", 0, c, false);\n        });\n\n        this.addEffect(skillDetails, \"skillMstId\", this.data.special_id, this.specialLvl, true);\n        this.addEffect(skillDetails, \"skillMstId\", this.data.attack_id, this.attackLvl, true);\n\n        this.addEffect(passiveDetails, \"passiveSkillMstId\", this.data.ability_id, this.abilityLvl, true);\n        let skillId = this.data.skill_id;\n        this.scalableEffects.forEach(e => {\n            if ((e as ActiveSkill).abilityEffectType === \"SWITCH_SKILL\") {\n                skillId = e.value1\n            }\n        });\n        this.addEffect(skillDetails, \"skillMstId\", skillId, this.skillLvl, true);\n\n        [...this.unscalableEffects, ...this.scalableEffects].forEach(e => {\n            if (e.abilityEffectType === \"UP_BUFF_EFFECT_VALUE\") {\n                this.buffMult += e.value1 / 1000;\n            } else if (e.abilityEffectType === \"UP_DEBUFF_EFFECT_VALUE\") {\n                this.debuffMult += e.value1 / 1000;\n            }\n            if (e.abilityEffectType === \"ADDITIONAL_SKILL_ACT\") {\n                this.addEffect(skillDetails, \"skillMstId\", 0, e.value1, true);\n            }\n        });\n        this.scalableEffects.forEach(e => {\n            if (e.abilityEffectType === \"TSUBAME_LINK\") {\n                this.scalableEffects.push(\n                    { ...e, abilityEffectType: \"UP_ATK_RATIO\", value1: e.value2, value2: 0, value3: 0 },\n                    { ...e, abilityEffectType: \"UP_DMG_DEALT\", value1: e.value3, value2: 0, value3: 0 }\n                )\n            }\n        })\n\n        this.effects = this.unscalableEffects.concat(this.scalableEffects.map(e => {\n            let v = e.value1;\n            if (e.abilityEffectType.startsWith(\"DWN_\") || e.abilityEffectType.startsWith(\"DOWN_\") || e.abilityEffectType.replace(\"AIM_\", \"\") === \"UP_RCV_DMG_RATIO\") {\n                v *= this.debuffMult;\n            } else if (e.abilityEffectType.startsWith(\"UP_\")) {\n                v *= this.buffMult;\n            }\n            return { ...e, value1: v }\n        }));\n        if (this.buffMult < 0) this.buffMult = 0;\n        if (this.debuffMult < 0) this.debuffMult = 0;\n    }\n\n    addEffect(map: Record<any, SkillDetail>, key: SkillKey, id: number, lvl: number, affectedByMult: boolean) {\n        (affectedByMult ? this.scalableEffects : this.unscalableEffects).push(...Object.values(map).filter(v => (v as any)[key] === id * 100 + lvl));\n    }\n}\n","import { FindBestTeamOptions } from \"../types/BestTeamTypes\";\nimport { ScoreAttackTeam } from \"./ScoreAttackTeam\";\nimport { KiokuRole, portraitsBestOnly, Character, KiokuElement, SupportKey, getBestCrystalises, KiokuConstants } from \"../types/KiokuTypes\";\nimport { ScoreAttackKioku } from \"./ScoreAttackKioku\";\n\nconst cache = new Map<string, ScoreAttackKioku>();\n\ninterface KiokuGeneratorArgs {\n    name: string;\n    kiokuLvl?: number;\n    magicLvl?: number;\n    heartphialLvl?: number;\n    portrait?: string;\n    supportKey?: any[];\n    crys?: string[];\n    crys_sub?: string[]\n    ascension?: number;\n    specialLvl?: number;\n    buffMultReduction?: number;\n    debuffMultReduction?: number;\n}\n\nexport function fromKey(key: any[]) {\n    return getKioku({\n        name: key[0],\n        supportKey: key[1],\n        portrait: key[2],\n        ascension: key[3],\n        kiokuLvl: key[4],\n        magicLvl: key[5],\n        heartphialLvl: key[6],\n        specialLvl: key[7],\n        crys: key[8],\n        crys_sub: key[9],\n    });\n}\n\nfunction getKioku({\n    name,\n    supportKey,\n    portrait,\n    ascension = KiokuConstants.maxAscension,\n    kiokuLvl = KiokuConstants.maxKiokuLvl,\n    magicLvl = KiokuConstants.maxMagicLvl,\n    heartphialLvl = KiokuConstants.maxHeartphialLvl,\n    specialLvl = KiokuConstants.maxSpecialLvl,\n    crys = [],\n    crys_sub = [],\n    buffMultReduction = 0,\n    debuffMultReduction = 0,\n}: KiokuGeneratorArgs): ScoreAttackKioku {\n    const clearCrys = crys.filter(Boolean)\n    const clearSubCrys = crys_sub.filter(Boolean)\n\n    const key = JSON.stringify([\n        name,\n        supportKey,\n        portrait,\n        ascension,\n        kiokuLvl,\n        magicLvl,\n        heartphialLvl,\n        specialLvl,\n        clearCrys,\n        clearSubCrys,\n    ]);\n\n    if (!cache.has(key)) {\n        cache.set(key, new ScoreAttackKioku({\n            name,\n            supportKey,\n            portrait,\n            ascension,\n            kiokuLvl,\n            magicLvl,\n            heartphialLvl,\n            specialLvl,\n            crys: clearCrys,\n            crys_sub: clearSubCrys\n        },\n            buffMultReduction,\n            debuffMultReduction));\n    }\n\n    return cache.get(key) as ScoreAttackKioku;\n}\n\nconst RELEVANT_SUPPORT_SUPPORTS = {\n    [KiokuRole.Buffer]: [\"Flame Waltz\", \"Buon Natale Grazioso\"]\n}\n\nexport async function findBestTeam({\n    enemies,\n    include4StarAttackers,\n    include4StarSupports,\n    include4StarOthers,\n    extraAttackers,\n    weakElements,\n    activeAliments,\n    enabledCharacters,\n    obligatoryKioku,\n    ignoredKioku,\n    deBufferCount,\n    otherCount,\n    minHealer,\n    minDefender,\n    minBreaker,\n    optimalSubCrys,\n    buffMultReduction,\n    offElementBuffMultReduction,\n    debuffMultReduction,\n    offElementDebuffMultReduction,\n    attackerHealth,\n    onProgress,\n    onError\n}: FindBestTeamOptions): Promise<any[]> {\n    const fetchKioku = (data: Character): ScoreAttackKioku => getKioku({\n        ...data,\n        buffMultReduction: weakElements.includes(data.element) ? buffMultReduction : offElementBuffMultReduction,\n        debuffMultReduction: weakElements.includes(data.element) ? debuffMultReduction : offElementDebuffMultReduction,\n    })\n\n    const perAttackerResults: Record<string, any[]> = {}\n    const availableChars: Record<KiokuRole, Character[]> = {\n        [KiokuRole.Attacker]: [],\n        [KiokuRole.Debuffer]: [],\n        [KiokuRole.Buffer]: [],\n        [KiokuRole.Healer]: [],\n        [KiokuRole.Breaker]: [],\n        [KiokuRole.Defender]: [],\n    }\n    enabledCharacters.forEach(char => {\n        if (!ignoredKioku.includes(char.name)) {\n            if (char.role === KiokuRole.Attacker) {\n                if (weakElements.includes(char.element) && ((char.rarity === 4 && char.role === KiokuRole.Attacker && include4StarAttackers) || char.rarity === 5)) {\n                    availableChars[KiokuRole.Attacker].push(char)\n                }\n            } else if (char.rarity === 5 ||\n                (char.rarity === 4 &&\n                    ((include4StarSupports && [KiokuRole.Buffer, KiokuRole.Debuffer].includes(char.role))\n                        || (include4StarOthers && [KiokuRole.Healer, KiokuRole.Defender, KiokuRole.Breaker].includes(char.role)))\n                )) {\n                availableChars[char.role].push(char)\n            }\n            if (extraAttackers.includes(char.name)) availableChars[KiokuRole.Attacker].push(char)\n        }\n    })\n\n    const availableSupportCombinations = combinations([...availableChars[KiokuRole.Debuffer], ...availableChars[KiokuRole.Buffer]], deBufferCount)\n    const availableOtherDistributions = generateRoleDistributions(otherCount, minHealer, minDefender, minBreaker)\n\n    const all5StarKioku = enabledCharacters.filter(c => c.rarity === 5).map(fetchKioku).filter(Boolean)\n    const highestAtkSupportKey = all5StarKioku.reduce((max, k) => (k.getBaseAtk() > max.getBaseAtk() ? k : max))?.getKey()\n    const possibleAtkSupportKeys: Record<SupportKey, any[]> = {\n        ...Object.values(KiokuRole).reduce(\n            (acc, role) => ({ ...acc, [role]: [] }), {}),\n        ...Object.values(KiokuElement).reduce(\n            (acc, el) => ({ ...acc, [el]: [] }), {})\n    }\n    for (const key of [...Object.values(KiokuRole), ...Object.values(KiokuElement)]) {\n        for (const c of all5StarKioku) {\n            if (c?.data.support_target == key) {\n                possibleAtkSupportKeys[key].push(c.getKey())\n            }\n        }\n    }\n\n    const bufferSupportData: any[][] = RELEVANT_SUPPORT_SUPPORTS[KiokuRole.Buffer]\n        .map(n => enabledCharacters.find(c => c.name === n))\n        .filter(Boolean)\n        .map(c => fetchKioku(c as Character))\n        .filter(Boolean)\n        .map(c => c.getKey());\n\n    let completedRuns = 0;\n    const expectedTotalRuns =\n        availableChars[KiokuRole.Attacker].length *\n        availableSupportCombinations.length *\n        availableOtherDistributions.reduce((sum, dist) => {\n            return sum +\n                nCr(availableChars[KiokuRole.Healer].length, dist.healers) *\n                nCr(availableChars[KiokuRole.Defender].length, dist.defenders) *\n                nCr(availableChars[KiokuRole.Breaker].length, dist.breakers);\n        }, 0);\n\n    for (const attacker of availableChars[KiokuRole.Attacker]) {\n        perAttackerResults[attacker.name] = []\n        const availablePortraits = portraitsBestOnly(attacker.element)\n        const availableSupportKeys: any[][] = Array.from([highestAtkSupportKey, ...possibleAtkSupportKeys[attacker.element], ...possibleAtkSupportKeys[attacker.role]].filter(s => s?.[0] !== attacker.name).reduce((map, item) => {\n            if (item && !map.has(item[0])) {\n                map.set(item[0], item)\n            }\n            return map\n        }, new Map()).values())\n        if (!availableSupportKeys.length) {\n            availableSupportKeys.push(fetchKioku(enabledCharacters.find(c => c.name === \"White Camellia\") ?? {\n                name: \"White Camellia\",\n            }).getKey())\n        }\n        for (const dist of availableOtherDistributions) {\n            for (const healerCombo of combinations(availableChars[KiokuRole.Healer], dist.healers)) {\n                for (const defenderCombo of combinations(availableChars[KiokuRole.Defender], dist.defenders)) {\n                    for (const breakerCombo of combinations(availableChars[KiokuRole.Breaker], dist.breakers)) {\n                        for (const deBufferCombo of availableSupportCombinations) {\n                            completedRuns += 1;\n\n                            const totalSupports = [\n                                ...healerCombo,\n                                ...defenderCombo,\n                                ...breakerCombo,\n                                ...deBufferCombo\n                            ]\n\n                            if (totalSupports.map(c => c.name).includes(attacker.name)) continue;\n\n                            const teamNames = [attacker, ...totalSupports].map(c => c.name).sort();\n                            if (obligatoryKioku.length) {\n                                if (!obligatoryKioku.every(k => teamNames.includes(k))) continue;\n                            }\n\n                            const activeDeBufferSupports = bufferSupportData.filter(s => !deBufferCombo.map(c => c.name).includes(s[0]))\n                            const supportSupports = [];\n                            if (activeDeBufferSupports.length) {\n                                const bufferIndexes = totalSupports.map((c, idx) => c.role === KiokuRole.Buffer ? idx : null).filter(v => v !== null) as number[]\n                                const combos = combinations(activeDeBufferSupports, Math.min(activeDeBufferSupports.length, bufferIndexes.length));\n                                for (const combo of combos) {\n                                    const perms = permute(combo);\n                                    for (const p of perms) {\n                                        const arr = new Array(totalSupports.length).fill(undefined);\n                                        for (let i = 0; i < p.length; i++)                                             arr[bufferIndexes[i]] = p[i];\n                                        supportSupports.push(arr);\n                                    }\n                                }\n                            } else {\n                                supportSupports.push(new Array(totalSupports.length).fill(undefined));\n                            }\n\n                            onProgress?.([attacker.name, ...totalSupports.map(s => s.name)], completedRuns, expectedTotalRuns)\n\n                            for (const attackerSupportKey of availableSupportKeys) {\n                                if (teamNames.includes(attackerSupportKey[0])) continue;\n                                for (const attackerPortrait of availablePortraits) {\n                                    for (const supportSupport of supportSupports) {\n                                        for (const attackerCrys of combinations(getBestCrystalises(attacker.element), 3)) {\n                                            try {\n                                                const team = new ScoreAttackTeam(\n                                                    fetchKioku({\n                                                        ...attacker,\n                                                        portrait: attackerPortrait,\n                                                        crys: attackerCrys,\n                                                        crys_sub: optimalSubCrys ? KiokuConstants.optimal_attacker_crys_sub : attacker.crys_sub,\n                                                        supportKey: attackerSupportKey,\n                                                    })!,\n                                                    totalSupports.map((s, i) => fetchKioku({\n                                                        ...s,\n                                                        crys: optimalSubCrys ? [\"EX\"] : s.crys,\n                                                        supportKey: supportSupport[i],\n                                                    })!),\n                                                    attackerHealth,\n                                                    activeAliments\n                                                );\n\n                                                const [dmg, _, critRate] = team.calculate_max_dmg(enemies, 0)\n                                                const entry = [\n                                                    dmg | 0,\n                                                    critRate,\n                                                    attacker.name,\n                                                    attackerPortrait,\n                                                    attackerSupportKey?.[0],\n                                                    ...attackerCrys,\n                                                    ...totalSupports.flatMap((s, i) => [s.name, supportSupport[i]?.[0]])\n                                                ]\n\n                                                perAttackerResults[attacker.name].push(entry)\n                                                if (completedRuns % 100 === 0) {\n                                                    perAttackerResults[attacker.name].sort((a, b) => b[0] - a[0])\n                                                    if (perAttackerResults[attacker.name].length > 100) perAttackerResults[attacker.name].length = 100\n                                                }\n                                            } catch (e) {\n                                                onError?.(e)\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return Object.values(perAttackerResults).flat()\n}\n\nfunction permute(arr: any[]): any[][] {\n    if (arr.length <= 1) return [arr];\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n        const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\n        for (const r of permute(rest)) result.push([arr[i], ...r]);\n    }\n    return result;\n}\n\nfunction combinations<T>(arr: T[], k: number): T[][] {\n    if (k === 0) return [[]];\n    if (k > arr.length) return [];\n\n    const result: T[][] = [];\n    const comb = (start: number, acc: T[]) => {\n        if (acc.length === k) {\n            result.push([...acc]);\n            return;\n        }\n        for (let i = start; i < arr.length; i++) {\n            acc.push(arr[i]);\n            comb(i + 1, acc);\n            acc.pop();\n        }\n    };\n    comb(0, []);\n    return result;\n}\n\nfunction generateRoleDistributions(otherCount: number, minHealer: number, minDefender: number, minBreaker: number): { healers: number, defenders: number, breakers: number }[] {\n    const distributions: { healers: number, defenders: number, breakers: number }[] = [];\n    for (let healers = minHealer; healers <= otherCount; healers++) {\n        for (let defenders = minDefender; defenders <= otherCount - healers; defenders++) {\n            const breakers = otherCount - healers - defenders;\n            if (breakers >= minBreaker) {\n                distributions.push({ healers, defenders, breakers });\n            }\n        }\n    }\n    return distributions;\n}\n\nfunction nCr(n: number, r: number): number {\n    if (r < 0 || r > n) return 0;\n    if (r === 0 || r === n) return 1;\n    let res = 1;\n    for (let i = 1; i <= r; i++) {\n        res = res * (n - i + 1) / i;\n    }\n    return res;\n}","import { findBestTeam } from '../models/BestTeamCalculator'\n\nself.onmessage = async (e) => {\n    const { options } = e.data\n\n    const onProgress = (currChars, completedRuns, expectedTotalRuns) => {\n        self.postMessage({ type: 'progress', currChars, completedRuns, expectedTotalRuns })\n    }\n    const onError = (error) => {\n        self.postMessage({ type: 'error', error })\n    }\n    const results = await findBestTeam({ ...options, onProgress, onError })\n    self.postMessage({ type: 'done', results })\n}\n"],"names":["EnemyTargetTypes","battleConditions","battleConditionsJson","item","battleConditionSets","battleConditionSetsJson","CompareContent","CompareOperator","CompareTarget","c","isCondActive","cond","valueToCompareTo","lateGetIsActiveCond","amountOfEnemies","maxBreak","isStartCondRelevantForScoreAttack","startConditionId","maxMagicStacks","battleConditionSet","activeCondId","battleCondition","isActiveConditionRelevantForScoreAttack","activeConditionSetId","attackerHealth","activeAliments","portraitLevels","portraitLevelsJson","portraits","portraitsJson","passiveDetails","passiveDetailsJson","skillDetails","skillDetailsJson","crystalises","selectionAbilityJson","styleParamUpEffect","styleParamUpEffectJson","styleParamUp","styleParamUpJson","characterHeartParamUpGroup","characterHeartParamUpGroupJson","characterHeart","characterHeartJson","kiokuData","kiokuDataJson","KiokuElement","Aliment","KiokuRole","elementMap","portraitsBestOnly","elem","skillDetailId","d","getBestCrystalises","elementalCrystalises","KiokuConstants","targetTypeAtPosition","knownBoosts","skippable","bannedEffects","prettyNumber","n","rounded","ScoreAttackTeam","dps","team","debug","members","t","_","kioku","detail","isDps","startCondId","valueTotal","isActiveCond","key","leftover","idx","enemies","atk_down","dmg","avg_dmg","enemyDied","total_dmg","average_dmg","critRate","debugText","e","debugTexts","i","eff","val","fun","v","targetType","nrHitThatKills","uses_def","delta_dmg","kiokuAtPosition","enemy","special","base_atk","atk_pluss","flat_atk","atk_total","def_remaining","def_total","uncapped_crit_rate","crit_rate","crit_dmg","dmg_pluss","elem_dmg_up","dmg_taken","elem_res_down","base_dmg","def_factor","crit_factor","crit_average","dmg_dealt_factor","dmg_taken_factor","elem_resist_factor","effect_elem_factor","break_factor","before_crit_total","total","average_total","lines","a","b","effects","st","outString","desc","Kioku","name","supportKey","portrait","ascension","kiokuLvl","magicLvl","heartphialLvl","specialLvl","crys","crys_sub","fromKey","heartGroup","styleParamUpEffectMstId","isMagic","ScoreAttackKioku","args","buffMultReduction","debuffMultReduction","passiveId","skillId","map","id","lvl","affectedByMult","cache","getKioku","clearCrys","clearSubCrys","RELEVANT_SUPPORT_SUPPORTS","findBestTeam","include4StarAttackers","include4StarSupports","include4StarOthers","extraAttackers","weakElements","enabledCharacters","obligatoryKioku","ignoredKioku","deBufferCount","otherCount","minHealer","minDefender","minBreaker","optimalSubCrys","offElementBuffMultReduction","offElementDebuffMultReduction","onProgress","onError","fetchKioku","data","perAttackerResults","availableChars","char","availableSupportCombinations","combinations","availableOtherDistributions","generateRoleDistributions","all5StarKioku","highestAtkSupportKey","max","k","possibleAtkSupportKeys","acc","role","el","bufferSupportData","completedRuns","expectedTotalRuns","sum","dist","nCr","attacker","availablePortraits","availableSupportKeys","s","healerCombo","defenderCombo","breakerCombo","deBufferCombo","totalSupports","teamNames","activeDeBufferSupports","supportSupports","bufferIndexes","combos","combo","perms","permute","p","arr","attackerSupportKey","attackerPortrait","supportSupport","attackerCrys","entry","result","rest","r","comb","start","distributions","healers","defenders","breakers","res","options","results","currChars","error"],"mappings":"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"}